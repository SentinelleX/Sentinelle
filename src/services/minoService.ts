/**
 * TinyFish/Mino Web Automation Service
 * Used for EHR documentation and form filling
 */

const MINO_API_URL = 'https://api.tinyfish.io/v1'

interface AutomationResult {
  success: boolean
  data?: {
    status: string
    result?: any
    screenshot?: string
  }
  error?: string
}

interface MinoCallbacks {
  onStart: () => void
  onProgress: (message: string, screenshot?: string) => void
  onComplete: (result: AutomationResult) => void
  onError: (error: Error) => void
}

interface DocumentationData {
  patientId: string
  patientName: string
  mrn: string
  timestamp: string
  vitals: {
    heartRate: number
    bloodPressure: { systolic: number; diastolic: number }
    temperature: number
    spO2: number
    respiratoryRate: number
  }
  assessment: string
  scores: {
    qsofa: number
    news2: number
  }
  recommendations: string[]
  alertLevel: string
}

/**
 * Simulate EHR documentation when API unavailable
 */
async function simulateEHRDocumentation(
  data: DocumentationData,
  callbacks: MinoCallbacks
): Promise<AutomationResult> {
  callbacks.onStart()
  callbacks.onProgress('Connecting to EHR system...')
  await new Promise(resolve => setTimeout(resolve, 600))

  callbacks.onProgress('Authenticating with Epic MyChart...')
  await new Promise(resolve => setTimeout(resolve, 800))

  callbacks.onProgress('Navigating to patient record...')
  await new Promise(resolve => setTimeout(resolve, 700))

  callbacks.onProgress(`Opening chart for ${data.patientName} (MRN: ${data.mrn})...`)
  await new Promise(resolve => setTimeout(resolve, 600))

  callbacks.onProgress('Creating new clinical note...')
  await new Promise(resolve => setTimeout(resolve, 900))

  callbacks.onProgress('Populating vital signs and assessment data...')
  await new Promise(resolve => setTimeout(resolve, 800))

  callbacks.onProgress('Attaching sepsis screening results...')
  await new Promise(resolve => setTimeout(resolve, 500))

  callbacks.onProgress('Saving note and flagging for physician review...')
  await new Promise(resolve => setTimeout(resolve, 700))

  const result: AutomationResult = {
    success: true,
    data: {
      status: 'completed',
      result: {
        noteId: `NOTE-${Date.now()}`,
        status: 'pending_cosign',
        createdAt: new Date().toISOString(),
      },
    },
  }

  callbacks.onComplete(result)
  return result
}

/**
 * Simulate pager alert when API unavailable
 */
async function simulatePagerAlert(
  pagerNumber: string,
  callbacks: MinoCallbacks
): Promise<AutomationResult> {
  callbacks.onStart()
  callbacks.onProgress(`Connecting to paging system for ${pagerNumber}...`)
  await new Promise(resolve => setTimeout(resolve, 500))

  callbacks.onProgress('Authenticating with hospital pager network...')
  await new Promise(resolve => setTimeout(resolve, 600))

  callbacks.onProgress('Composing STAT alert message...')
  await new Promise(resolve => setTimeout(resolve, 400))

  callbacks.onProgress(`Transmitting to pager ${pagerNumber}...`)
  await new Promise(resolve => setTimeout(resolve, 800))

  callbacks.onProgress('Confirming delivery...')
  await new Promise(resolve => setTimeout(resolve, 500))

  const result: AutomationResult = {
    success: true,
    data: {
      status: 'completed',
      result: {
        messageId: `PAGE-${Date.now()}`,
        deliveredAt: new Date().toISOString(),
        pagerNumber,
      },
    },
  }

  callbacks.onComplete(result)
  return result
}

/**
 * Generate clinical documentation via Mino automation
 */
export async function generateEHRDocumentation(
  data: DocumentationData,
  callbacks: MinoCallbacks
): Promise<AutomationResult> {
  const apiKey = import.meta.env.VITE_MINO_API_KEY

  // If no API key, use simulation
  if (!apiKey) {
    return simulateEHRDocumentation(data, callbacks)
  }

  callbacks.onStart()
  callbacks.onProgress('Connecting to EHR system...')

  const documentationNote = `
CLINICAL ALERT - AUTOMATED SEPSIS SCREENING

Patient: ${data.patientName}
MRN: ${data.mrn}
Date/Time: ${data.timestamp}

VITAL SIGNS:
- Heart Rate: ${data.vitals.heartRate} bpm
- Blood Pressure: ${data.vitals.bloodPressure.systolic}/${data.vitals.bloodPressure.diastolic} mmHg
- Temperature: ${data.vitals.temperature}Â°C
- SpO2: ${data.vitals.spO2}%
- Respiratory Rate: ${data.vitals.respiratoryRate}/min

CLINICAL SCORES:
- qSOFA Score: ${data.scores.qsofa}/3
- NEWS2 Score: ${data.scores.news2}

AUTOMATED ASSESSMENT:
${data.assessment}

RECOMMENDATIONS:
${data.recommendations.map((r, i) => `${i + 1}. ${r}`).join('\n')}

ALERT LEVEL: ${data.alertLevel}

---
Generated by Sentinelle Autonomous Clinical Intelligence System
This note requires physician co-signature.
`.trim()

  try {
    // Use Mino's SSE endpoint for real-time progress
    const response = await fetch(`${MINO_API_URL}/automation/run-sse`, {
      method: 'POST',
      headers: {
        'X-API-Key': apiKey,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        goal: `Create a new clinical note in the EHR with the following content:\n\n${documentationNote}`,
        url: 'https://ehr-demo.example.com/documentation/new',
        timeout: 60000,
        return_screenshot: true,
      }),
    })

    if (!response.ok) {
      // Fall back to simulation
      return simulateEHRDocumentation(data, callbacks)
    }

    // Handle SSE stream
    const reader = response.body?.getReader()
    const decoder = new TextDecoder()

    if (!reader) {
      return simulateEHRDocumentation(data, callbacks)
    }

    let lastResult: AutomationResult = { success: false }

    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      const chunk = decoder.decode(value)
      const lines = chunk.split('\n').filter(line => line.trim())

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const eventData = JSON.parse(line.slice(6))

            if (eventData.type === 'STEP' || eventData.type === 'PROGRESS') {
              callbacks.onProgress(
                eventData.message || eventData.description || 'Processing...',
                eventData.screenshot
              )
            }

            if (eventData.type === 'COMPLETE' || eventData.status === 'COMPLETED') {
              lastResult = {
                success: true,
                data: {
                  status: 'completed',
                  result: eventData.result || eventData.resultJson,
                  screenshot: eventData.screenshot,
                },
              }
            }

            if (eventData.type === 'ERROR' || eventData.status === 'FAILED') {
              return simulateEHRDocumentation(data, callbacks)
            }
          } catch {
            // Ignore parse errors for non-JSON lines
          }
        }
      }
    }

    if (lastResult.success) {
      callbacks.onComplete(lastResult)
      return lastResult
    }

    return simulateEHRDocumentation(data, callbacks)
  } catch {
    return simulateEHRDocumentation(data, callbacks)
  }
}

/**
 * Send alert to care team via pager system automation
 */
export async function sendPagerAlert(
  pagerNumber: string,
  message: string,
  callbacks: MinoCallbacks
): Promise<AutomationResult> {
  const apiKey = import.meta.env.VITE_MINO_API_KEY

  // If no API key, use simulation
  if (!apiKey) {
    return simulatePagerAlert(pagerNumber, callbacks)
  }

  callbacks.onStart()
  callbacks.onProgress(`Connecting to paging system for ${pagerNumber}...`)

  try {
    const response = await fetch(`${MINO_API_URL}/automation/run`, {
      method: 'POST',
      headers: {
        'X-API-Key': apiKey,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        goal: `Send a STAT page to pager number ${pagerNumber} with the message: "${message}"`,
        url: 'https://pager-system.example.com',
        timeout: 30000,
      }),
    })

    if (!response.ok) {
      return simulatePagerAlert(pagerNumber, callbacks)
    }

    const result = await response.json()

    if (result.status === 'COMPLETED' || result.success) {
      const automationResult: AutomationResult = {
        success: true,
        data: {
          status: 'completed',
          result: result.result,
        },
      }
      callbacks.onComplete(automationResult)
      return automationResult
    }

    return simulatePagerAlert(pagerNumber, callbacks)
  } catch {
    return simulatePagerAlert(pagerNumber, callbacks)
  }
}

/**
 * Extract data from external lab system
 */
export async function extractLabResults(
  patientId: string,
  callbacks: MinoCallbacks
): Promise<AutomationResult> {
  const apiKey = import.meta.env.VITE_MINO_API_KEY

  // Simulation for lab results
  const simulateLabExtraction = async (): Promise<AutomationResult> => {
    callbacks.onStart()
    callbacks.onProgress('Connecting to lab information system...')
    await new Promise(resolve => setTimeout(resolve, 600))

    callbacks.onProgress('Querying patient lab records...')
    await new Promise(resolve => setTimeout(resolve, 800))

    callbacks.onProgress('Extracting results from last 24 hours...')
    await new Promise(resolve => setTimeout(resolve, 700))

    const result: AutomationResult = {
      success: true,
      data: {
        status: 'completed',
        result: [
          { test_name: 'Lactate', value: '3.2', unit: 'mmol/L', reference_range: '0.5-2.0', abnormal_flag: 'H', timestamp: new Date().toISOString() },
          { test_name: 'WBC', value: '14.2', unit: 'x10^9/L', reference_range: '4.5-11.0', abnormal_flag: 'H', timestamp: new Date().toISOString() },
          { test_name: 'Procalcitonin', value: '2.8', unit: 'ng/mL', reference_range: '<0.5', abnormal_flag: 'H', timestamp: new Date().toISOString() },
        ],
      },
    }
    callbacks.onComplete(result)
    return result
  }

  if (!apiKey) {
    return simulateLabExtraction()
  }

  callbacks.onStart()
  callbacks.onProgress('Connecting to lab information system...')

  try {
    const response = await fetch(`${MINO_API_URL}/automation/run`, {
      method: 'POST',
      headers: {
        'X-API-Key': apiKey,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        goal: `Navigate to patient ${patientId}'s lab results and extract all results from the last 24 hours. Return as JSON with fields: test_name, value, unit, reference_range, abnormal_flag, timestamp`,
        url: 'https://lab-system.example.com',
        timeout: 45000,
        return_json: true,
      }),
    })

    if (!response.ok) {
      return simulateLabExtraction()
    }

    const result = await response.json()

    if (result.status === 'COMPLETED' || result.success) {
      const automationResult: AutomationResult = {
        success: true,
        data: {
          status: 'completed',
          result: result.resultJson || result.result,
        },
      }
      callbacks.onComplete(automationResult)
      return automationResult
    }

    return simulateLabExtraction()
  } catch {
    return simulateLabExtraction()
  }
}
